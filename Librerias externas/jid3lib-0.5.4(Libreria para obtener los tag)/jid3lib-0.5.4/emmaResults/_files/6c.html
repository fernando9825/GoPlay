<HTML><HEAD><META CONTENT="text/html; charset=ISO-8859-1" HTTP-EQUIV="Content-Type"/><TITLE>EMMA Coverage Report</TITLE><STYLE TYPE="text/css"> TABLE,TD,TH {border-style:solid; border-color:black;} TD,TH {background:white;margin:0;line-height:100%;padding-left:0.5em;padding-right:0.5em;} TD {border-width:0 1px 0 0;} TH {border-width:1px 1px 1px 0;} TR TD.h {color:red;} TABLE {border-spacing:0; border-collapse:collapse;border-width:0 0 1px 1px;} P,H1,H2,H3,TH {font-family:verdana,arial,sans-serif;font-size:10pt;} TD {font-family:courier,monospace;font-size:10pt;} TABLE.hdft {border-spacing:0;border-collapse:collapse;border-style:none;} TABLE.hdft TH,TABLE.hdft TD {border-style:none;line-height:normal;} TABLE.hdft TH.tl,TABLE.hdft TD.tl {background:#6699CC;color:white;} TABLE.hdft TD.nv {background:#6633DD;color:white;} .nv A:link {color:white;} .nv A:visited {color:white;} .nv A:active {color:yellow;} TABLE.hdft A:link {color:white;} TABLE.hdft A:visited {color:white;} TABLE.hdft A:active {color:yellow;} .in {color:#356085;} TABLE.s TD {padding-left:0.25em;padding-right:0.25em;} TABLE.s TD.l {padding-left:0.25em;padding-right:0.25em;text-align:right;background:#F0F0F0;} TABLE.s TR.z TD {background:#FF9999;} TABLE.s TR.p TD {background:#FFFF88;} TABLE.s TR.c TD {background:#CCFFCC;} A:link {color:#0000EE;text-decoration:none;} A:visited {color:#0000EE;text-decoration:none;} A:hover {color:#0000EE;text-decoration:underline;} TABLE.cn {border-width:0 0 1px 0;} TABLE.s {border-width:1px 0 1px 1px;} TD.h {color:red;border-width:0 1px 0 0;} TD.f {border-width:0 1px 0 1px;} TD.hf {color:red;border-width:0 1px 0 1px;} TH.f {border-width:1px 1px 1px 1px;} TR.cis TD {background:#F0F0F0;} TR.cis TD {border-width:1px 1px 1px 0;} TR.cis TD.h {color:red;border-width:1px 1px 1px 0;} TR.cis TD.f {border-width:1px 1px 1px 1px;} TR.cis TD.hf {color:red;border-width:1px 1px 1px 1px;} TD.b {border-style:none;background:transparent;line-height:50%;}  TD.bt {border-width:1px 0 0 0;background:transparent;line-height:50%;} TR.o TD {background:#F0F0F0;}TABLE.it {border-style:none;}TABLE.it TD,TABLE.it TH {border-style:none;}</STYLE></HEAD><BODY><TABLE CLASS="hdft" WIDTH="100%" CELLSPACING="0"><TR><TH CLASS="tl"><A HREF="http://emma.sourceforge.net/">EMMA</A> Coverage Report (generated Tue Mar 14 21:50:42 EST 2006)</TH></TR><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="0.html">org.farng.mp3.id3</A>]</TD></TR></TABLE><H2>COVERAGE SUMMARY FOR SOURCE FILE [<SPAN CLASS="in">ID3v2_4Frame.java</SPAN>]</H2><TABLE WIDTH="100%" CELLSPACING="0"><TR><TH>name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD>ID3v2_4Frame.java</TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>86%  (582/679)</TD><TD>90%  (127.2/141)</TD></TR></TABLE><H3>COVERAGE BREAKDOWN BY CLASS AND METHOD</H3><TABLE CLASS="cn" WIDTH="100%" CELLSPACING="0"><TR><TH CLASS="f">name</TH><TH>class, %</TH><TH>method, %</TH><TH>block, %</TH><TH>line, %</TH></TR><TR><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD><TD CLASS="b"> </TD></TR><TR CLASS="cis"><TD CLASS="f">class <A HREF="#0">ID3v2_4Frame</A></TD><TD>100% (1/1)</TD><TD>100% (11/11)</TD><TD>86%  (582/679)</TD><TD>90%  (127.2/141)</TD></TR><TR><TD CLASS="f"><A HREF="#1">write (RandomAccessFile): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">62%  (91/147)</TD><TD CLASS="h">77%  (23/30)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#2">equals (Object): boolean</A></TD><TD> </TD><TD>100% (1/1)</TD><TD CLASS="h">77%  (20/26)</TD><TD CLASS="h">62%  (5/8)</TD></TR><TR><TD CLASS="f"><A HREF="#3">ID3v2_4Frame (Lyrics3v2Field): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>88%  (166/189)</TD><TD>92%  (36/39)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#4">read (RandomAccessFile): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>93%  (149/160)</TD><TD>98%  (25.4/26)</TD></TR><TR><TD CLASS="f"><A HREF="#5">ID3v2_4Frame (AbstractID3v2Frame): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>99%  (69/70)</TD><TD>99%  (19.8/20)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#0">ID3v2_4Frame (): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (9/9)</TD><TD>100% (4/4)</TD></TR><TR><TD CLASS="f"><A HREF="#7">ID3v2_4Frame (AbstractID3v2FrameBody): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (10/10)</TD><TD>100% (4/4)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#8">ID3v2_4Frame (ID3v2_4Frame): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (18/18)</TD><TD>100% (6/6)</TD></TR><TR><TD CLASS="f"><A HREF="#9">ID3v2_4Frame (RandomAccessFile): void</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (12/12)</TD><TD>100% (5/5)</TD></TR><TR CLASS="o"><TD CLASS="f"><A HREF="#a">ID3v2_4Frame (boolean, boolean, boolean, boolean, boolean, boolean, AbstractI...</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (28/28)</TD><TD>100% (10/10)</TD></TR><TR><TD CLASS="f"><A HREF="#b">getSize (): int</A></TD><TD> </TD><TD>100% (1/1)</TD><TD>100% (10/10)</TD><TD>100% (1/1)</TD></TR></TABLE><P></P><TABLE CLASS="s" WIDTH="100%" CELLSPACING="0"><TR><TD CLASS="l">1</TD><TD>package org.farng.mp3.id3;</TD></TR><TR><TD CLASS="l">2</TD><TD> </TD></TR><TR><TD CLASS="l">3</TD><TD>import org.farng.mp3.InvalidTagException;</TD></TR><TR><TD CLASS="l">4</TD><TD>import org.farng.mp3.TagConstant;</TD></TR><TR><TD CLASS="l">5</TD><TD>import org.farng.mp3.TagUtility;</TD></TR><TR><TD CLASS="l">6</TD><TD>import org.farng.mp3.lyrics3.FieldBodyAUT;</TD></TR><TR><TD CLASS="l">7</TD><TD>import org.farng.mp3.lyrics3.FieldBodyEAL;</TD></TR><TR><TD CLASS="l">8</TD><TD>import org.farng.mp3.lyrics3.FieldBodyEAR;</TD></TR><TR><TD CLASS="l">9</TD><TD>import org.farng.mp3.lyrics3.FieldBodyETT;</TD></TR><TR><TD CLASS="l">10</TD><TD>import org.farng.mp3.lyrics3.FieldBodyINF;</TD></TR><TR><TD CLASS="l">11</TD><TD>import org.farng.mp3.lyrics3.FieldBodyLYR;</TD></TR><TR><TD CLASS="l">12</TD><TD>import org.farng.mp3.lyrics3.Lyrics3v2Field;</TD></TR><TR><TD CLASS="l">13</TD><TD>import org.farng.mp3.object.ObjectLyrics3Line;</TD></TR><TR><TD CLASS="l">14</TD><TD> </TD></TR><TR><TD CLASS="l">15</TD><TD>import java.io.IOException;</TD></TR><TR><TD CLASS="l">16</TD><TD>import java.io.RandomAccessFile;</TD></TR><TR><TD CLASS="l">17</TD><TD>import java.util.Iterator;</TD></TR><TR><TD CLASS="l">18</TD><TD> </TD></TR><TR><TD CLASS="l">19</TD><TD>/**</TD></TR><TR><TD CLASS="l">20</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; All ID3v2 frames consists of one frame header followed by one or more&lt;br&gt; &amp;nbsp;&amp;nbsp; fields</TD></TR><TR><TD CLASS="l">21</TD><TD> * containing the actual information. The header is always 10&lt;br&gt; &amp;nbsp;&amp;nbsp; bytes and laid out as follows:&lt;/p&gt;</TD></TR><TR><TD CLASS="l">22</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">23</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame ID&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; $xx xx xx xx&amp;nbsp; (four characters)&lt;br&gt;</TD></TR><TR><TD CLASS="l">24</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Size&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 4 * %0xxxxxxx&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</TD></TR><TR><TD CLASS="l">25</TD><TD> * Flags&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; $xx xx&lt;/p&gt;</TD></TR><TR><TD CLASS="l">26</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">27</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; The frame ID is made out of the characters capital A-Z and 0-9.&lt;br&gt; &amp;nbsp;&amp;nbsp; Identifiers</TD></TR><TR><TD CLASS="l">28</TD><TD> * beginning with &amp;quot;X&amp;quot;, &amp;quot;Y&amp;quot; and &amp;quot;Z&amp;quot; are for experimental&lt;br&gt; &amp;nbsp;&amp;nbsp; frames and free</TD></TR><TR><TD CLASS="l">29</TD><TD> * for everyone to use, without the need to set the&lt;br&gt; &amp;nbsp;&amp;nbsp; experimental bit in the tag header. Bear in mind</TD></TR><TR><TD CLASS="l">30</TD><TD> * that someone else&lt;br&gt; &amp;nbsp;&amp;nbsp; might have used the same identifier as you. All other identifiers are&lt;br&gt;</TD></TR><TR><TD CLASS="l">31</TD><TD> * &amp;nbsp;&amp;nbsp; either used or reserved for future use.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">32</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">33</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; The frame ID is followed by a size descriptor containing the size of&lt;br&gt; &amp;nbsp;&amp;nbsp; the data in the</TD></TR><TR><TD CLASS="l">34</TD><TD> * final frame, after encryption, compression and&lt;br&gt; &amp;nbsp;&amp;nbsp; unsynchronisation. The size is excluding the frame</TD></TR><TR><TD CLASS="l">35</TD><TD> * header ('total&lt;br&gt; &amp;nbsp;&amp;nbsp; frame size' - 10 bytes) and stored as a 32 bit synchsafe integer.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">36</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">37</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; In the frame header the size descriptor is followed by two flag&lt;br&gt; &amp;nbsp;&amp;nbsp; bytes. These flags</TD></TR><TR><TD CLASS="l">38</TD><TD> * are described in section 4.1.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">39</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">40</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; There is no fixed order of the frames' appearance in the tag,&lt;br&gt; &amp;nbsp;&amp;nbsp; although it is desired</TD></TR><TR><TD CLASS="l">41</TD><TD> * that the frames are arranged in order of&lt;br&gt; &amp;nbsp;&amp;nbsp; significance concerning the recognition of the file. An</TD></TR><TR><TD CLASS="l">42</TD><TD> * example of&lt;br&gt; &amp;nbsp;&amp;nbsp; such order: UFID, TIT2, MCDI, TRCK ...&lt;/p&gt;</TD></TR><TR><TD CLASS="l">43</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">44</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; A tag MUST contain at least one frame. A frame must be at least 1&lt;br&gt; &amp;nbsp;&amp;nbsp; byte big,</TD></TR><TR><TD CLASS="l">45</TD><TD> * excluding the header.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">46</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">47</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; If nothing else is said, strings, including numeric strings and URLs&lt;br&gt; &amp;nbsp;&amp;nbsp; [URL], are</TD></TR><TR><TD CLASS="l">48</TD><TD> * represented as ISO-8859-1 [ISO-8859-1] characters in the&lt;br&gt; &amp;nbsp;&amp;nbsp; range $20 - $FF. Such strings are</TD></TR><TR><TD CLASS="l">49</TD><TD> * represented in frame descriptions&lt;br&gt; &amp;nbsp;&amp;nbsp; as &amp;lt;text string&amp;gt;, or &amp;lt;full text string&amp;gt; if newlines</TD></TR><TR><TD CLASS="l">50</TD><TD> * are allowed. If&lt;br&gt; &amp;nbsp;&amp;nbsp; nothing else is said newline character is forbidden. In ISO-8859-1 a&lt;br&gt;</TD></TR><TR><TD CLASS="l">51</TD><TD> * &amp;nbsp;&amp;nbsp; newline is represented, when allowed, with $0A only.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">52</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">53</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; Frames that allow different types of text encoding contains a text&lt;br&gt; &amp;nbsp;&amp;nbsp; encoding</TD></TR><TR><TD CLASS="l">54</TD><TD> * description byte. Possible encodings:&lt;/p&gt;</TD></TR><TR><TD CLASS="l">55</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">56</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; $00&amp;nbsp;&amp;nbsp; ISO-8859-1 [ISO-8859-1]. Terminated with $00.&lt;br&gt;</TD></TR><TR><TD CLASS="l">57</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; $01&amp;nbsp;&amp;nbsp; UTF-16 [UTF-16] encoded Unicode [UNICODE] with BOM. All&lt;br&gt;</TD></TR><TR><TD CLASS="l">58</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; strings in the same frame SHALL have the same</TD></TR><TR><TD CLASS="l">59</TD><TD> * byteorder.&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Terminated with $00 00.&lt;br&gt;</TD></TR><TR><TD CLASS="l">60</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; $02&amp;nbsp;&amp;nbsp; UTF-16BE [UTF-16] encoded Unicode [UNICODE] without BOM.&lt;br&gt;</TD></TR><TR><TD CLASS="l">61</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Terminated with $00 00.&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</TD></TR><TR><TD CLASS="l">62</TD><TD> * $03&amp;nbsp;&amp;nbsp; UTF-8 [UTF-8] encoded Unicode [UNICODE]. Terminated with $00.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">63</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">64</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; Strings dependent on encoding are represented in frame descriptions&lt;br&gt; &amp;nbsp;&amp;nbsp; as &amp;lt;text</TD></TR><TR><TD CLASS="l">65</TD><TD> * string according to encoding&amp;gt;, or &amp;lt;full text string&lt;br&gt; &amp;nbsp;&amp;nbsp; according to encoding&amp;gt; if newlines are</TD></TR><TR><TD CLASS="l">66</TD><TD> * allowed. Any empty strings of&lt;br&gt; &amp;nbsp;&amp;nbsp; type $01 which are NULL-terminated may have the Unicode BOM</TD></TR><TR><TD CLASS="l">67</TD><TD> * followed&lt;br&gt; &amp;nbsp;&amp;nbsp; by a Unicode NULL ($FF FE 00 00 or $FE FF 00 00).&lt;/p&gt;</TD></TR><TR><TD CLASS="l">68</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">69</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; The timestamp fields are based on a subset of ISO 8601. When being as&lt;br&gt; &amp;nbsp;&amp;nbsp; precise as</TD></TR><TR><TD CLASS="l">70</TD><TD> * possible the format of a time string is&lt;br&gt; &amp;nbsp;&amp;nbsp; yyyy-MM-ddTHH:mm:ss (year, &amp;quot;-&amp;quot;, month,</TD></TR><TR><TD CLASS="l">71</TD><TD> * &amp;quot;-&amp;quot;, day, &amp;quot;T&amp;quot;, hour (out of&lt;br&gt; &amp;nbsp;&amp;nbsp; 24), &amp;quot;:&amp;quot;, minutes, &amp;quot;:&amp;quot;,</TD></TR><TR><TD CLASS="l">72</TD><TD> * seconds), but the precision may be reduced by&lt;br&gt; &amp;nbsp;&amp;nbsp; removing as many time indicators as wanted. Hence</TD></TR><TR><TD CLASS="l">73</TD><TD> * valid timestamps&lt;br&gt; &amp;nbsp;&amp;nbsp; are&lt;br&gt; &amp;nbsp;&amp;nbsp; yyyy, yyyy-MM, yyyy-MM-dd, yyyy-MM-ddTHH, yyyy-MM-ddTHH:mm</TD></TR><TR><TD CLASS="l">74</TD><TD> * and&lt;br&gt; &amp;nbsp;&amp;nbsp; yyyy-MM-ddTHH:mm:ss. All time stamps are UTC. For durations, use&lt;br&gt; &amp;nbsp;&amp;nbsp; the slash</TD></TR><TR><TD CLASS="l">75</TD><TD> * character as described in 8601, and for multiple non-&lt;br&gt; &amp;nbsp;&amp;nbsp; contiguous dates, use multiple strings, if</TD></TR><TR><TD CLASS="l">76</TD><TD> * allowed by the frame&lt;br&gt; &amp;nbsp;&amp;nbsp; definition.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">77</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">78</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; The three byte language field, present in several frames, is used to&lt;br&gt; &amp;nbsp;&amp;nbsp; describe the</TD></TR><TR><TD CLASS="l">79</TD><TD> * language of the frame's content, according to ISO-639-2&lt;br&gt; &amp;nbsp;&amp;nbsp; [ISO-639-2]. The language should be</TD></TR><TR><TD CLASS="l">80</TD><TD> * represented in lower case. If the&lt;br&gt; &amp;nbsp;&amp;nbsp; language is not known the string &amp;quot;XXX&amp;quot; should be</TD></TR><TR><TD CLASS="l">81</TD><TD> * used.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">82</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">83</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; All URLs [URL] MAY be relative, e.g. &amp;quot;picture.png&amp;quot;, &amp;quot;../doc.txt&amp;quot;.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">84</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">85</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; If a frame is longer than it should be, e.g. having more fields than&lt;br&gt; &amp;nbsp;&amp;nbsp; specified in</TD></TR><TR><TD CLASS="l">86</TD><TD> * this document, that indicates that additions to the&lt;br&gt; &amp;nbsp;&amp;nbsp; frame have been made in a later version of the</TD></TR><TR><TD CLASS="l">87</TD><TD> * ID3v2 standard. This&lt;br&gt; &amp;nbsp;&amp;nbsp; is reflected by the revision number in the header of the tag.&lt;br&gt; &lt;/p&gt; &lt;a</TD></TR><TR><TD CLASS="l">88</TD><TD> * name=&#34;sec4.1&#34;&gt;&lt;/a&gt;</TD></TR><TR><TD CLASS="l">89</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">90</TD><TD> * &lt;h3&gt;4.1.&amp;nbsp;&amp;nbsp; Frame header flags&lt;/h3&gt;</TD></TR><TR><TD CLASS="l">91</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">92</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; In the frame header the size descriptor is followed by two flag&lt;br&gt; &amp;nbsp;&amp;nbsp; bytes. All unused</TD></TR><TR><TD CLASS="l">93</TD><TD> * flags MUST be cleared. The first byte is for&lt;br&gt; &amp;nbsp;&amp;nbsp; 'status messages' and the second byte is a format</TD></TR><TR><TD CLASS="l">94</TD><TD> * description. If an&lt;br&gt; &amp;nbsp;&amp;nbsp; unknown flag is set in the first byte the frame MUST NOT be changed&lt;br&gt;</TD></TR><TR><TD CLASS="l">95</TD><TD> * &amp;nbsp;&amp;nbsp; without that bit cleared. If an unknown flag is set in the second&lt;br&gt; &amp;nbsp;&amp;nbsp; byte the frame is</TD></TR><TR><TD CLASS="l">96</TD><TD> * likely to not be readable. Some flags in the second&lt;br&gt; &amp;nbsp;&amp;nbsp; byte indicates that extra information is added</TD></TR><TR><TD CLASS="l">97</TD><TD> * to the header. These&lt;br&gt; &amp;nbsp;&amp;nbsp; fields of extra information is ordered as the flags that indicates&lt;br&gt;</TD></TR><TR><TD CLASS="l">98</TD><TD> * &amp;nbsp;&amp;nbsp; them. The flags field is defined as follows (l and o left out because&lt;br&gt; &amp;nbsp;&amp;nbsp; ther resemblence</TD></TR><TR><TD CLASS="l">99</TD><TD> * to one and zero):&lt;/p&gt;</TD></TR><TR><TD CLASS="l">100</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">101</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; %0abc0000 %0h00kmnp&lt;/p&gt;</TD></TR><TR><TD CLASS="l">102</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">103</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; Some frame format flags indicate that additional information fields&lt;br&gt; &amp;nbsp;&amp;nbsp; are added to the</TD></TR><TR><TD CLASS="l">104</TD><TD> * frame. This information is added after the frame&lt;br&gt; &amp;nbsp;&amp;nbsp; header and before the frame data in the same order</TD></TR><TR><TD CLASS="l">105</TD><TD> * as the flags that&lt;br&gt; &amp;nbsp;&amp;nbsp; indicates them. I.e. the four bytes of decompressed size will precede&lt;br&gt;</TD></TR><TR><TD CLASS="l">106</TD><TD> * &amp;nbsp;&amp;nbsp; the encryption method byte. These additions affects the 'frame size'&lt;br&gt; &amp;nbsp;&amp;nbsp; field, but are not</TD></TR><TR><TD CLASS="l">107</TD><TD> * subject to encryption or compression.&lt;br&gt; &amp;nbsp;&amp;nbsp; &lt;/p&gt;</TD></TR><TR><TD CLASS="l">108</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">109</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; The default status flags setting for a frame is, unless stated&lt;br&gt; &amp;nbsp;&amp;nbsp; otherwise, 'preserved</TD></TR><TR><TD CLASS="l">110</TD><TD> * if tag is altered' and 'preserved if file is&lt;br&gt; &amp;nbsp;&amp;nbsp; altered', i.e. %00000000.&lt;br&gt; &lt;/p&gt; &lt;a</TD></TR><TR><TD CLASS="l">111</TD><TD> * name=&#34;sec4.1.1&#34;&gt;&lt;/a&gt;</TD></TR><TR><TD CLASS="l">112</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">113</TD><TD> * &lt;h3&gt;4.1.1. Frame status flags&lt;/h3&gt;</TD></TR><TR><TD CLASS="l">114</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">115</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; a - Tag alter preservation&lt;/p&gt;</TD></TR><TR><TD CLASS="l">116</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">117</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; This flag tells the tag parser what to do with this frame if it is&lt;br&gt;</TD></TR><TR><TD CLASS="l">118</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; unknown and the tag is altered in any way. This applies to all&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</TD></TR><TR><TD CLASS="l">119</TD><TD> * kinds of alterations, including adding more padding and reordering&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; the frames.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">120</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">121</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame should be preserved.&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</TD></TR><TR><TD CLASS="l">122</TD><TD> * 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame should be discarded.&lt;br&gt; &lt;/p&gt;</TD></TR><TR><TD CLASS="l">123</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">124</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; b - File alter preservation&lt;/p&gt;</TD></TR><TR><TD CLASS="l">125</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">126</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; This flag tells the tag parser what to do with this frame if it is&lt;br&gt;</TD></TR><TR><TD CLASS="l">127</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; unknown and the file, excluding the tag, is altered. This does not&lt;br&gt;</TD></TR><TR><TD CLASS="l">128</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; apply when the audio is completely replaced with other audio data.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">129</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">130</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame should be preserved.&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;</TD></TR><TR><TD CLASS="l">131</TD><TD> * 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame should be discarded.&lt;br&gt; &lt;/p&gt;</TD></TR><TR><TD CLASS="l">132</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">133</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; c - Read only&lt;/p&gt;</TD></TR><TR><TD CLASS="l">134</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">135</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; This flag, if set, tells the software that the contents of this&lt;br&gt;</TD></TR><TR><TD CLASS="l">136</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; frame are intended to be read only. Changing the contents might&lt;br&gt;</TD></TR><TR><TD CLASS="l">137</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; break something, e.g. a signature. If the contents are changed,&lt;br&gt;</TD></TR><TR><TD CLASS="l">138</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; without knowledge of why the frame was flagged read only and&lt;br&gt;</TD></TR><TR><TD CLASS="l">139</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; without taking the proper means to compensate, e.g. recalculating&lt;br&gt;</TD></TR><TR><TD CLASS="l">140</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; the signature, the bit MUST be cleared.&lt;br&gt; &lt;/p&gt; &lt;a name=&#34;sec4.1.2&#34;&gt;&lt;/a&gt;</TD></TR><TR><TD CLASS="l">141</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">142</TD><TD> * &lt;h3&gt;4.1.2. Frame format flags&lt;/h3&gt;</TD></TR><TR><TD CLASS="l">143</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">144</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; h - Grouping identity&lt;/p&gt;</TD></TR><TR><TD CLASS="l">145</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">146</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; This flag indicates whether or not this frame belongs in a group&lt;br&gt;</TD></TR><TR><TD CLASS="l">147</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; with other frames. If set, a group identifier byte is added to the&lt;br&gt;</TD></TR><TR><TD CLASS="l">148</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; frame. Every frame with the same group identifier belongs to the&lt;br&gt;</TD></TR><TR><TD CLASS="l">149</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; same group.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">150</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">151</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame does not contain group information&lt;br&gt;</TD></TR><TR><TD CLASS="l">152</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame contains group information&lt;br&gt; &lt;/p&gt;</TD></TR><TR><TD CLASS="l">153</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">154</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; k - Compression&lt;/p&gt;</TD></TR><TR><TD CLASS="l">155</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">156</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; This flag indicates whether or not the frame is compressed.&lt;br&gt;</TD></TR><TR><TD CLASS="l">157</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; A 'Data Length Indicator' byte MUST be included in the frame.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">158</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">159</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame is not compressed.&lt;br&gt;</TD></TR><TR><TD CLASS="l">160</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame is compressed using zlib [zlib] deflate method.&lt;br&gt;</TD></TR><TR><TD CLASS="l">161</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; If set, this requires the 'Data Length Indicator'</TD></TR><TR><TD CLASS="l">162</TD><TD> * bit&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; to be set as well.&lt;br&gt; &lt;/p&gt;</TD></TR><TR><TD CLASS="l">163</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">164</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; m - Encryption&lt;br&gt; &amp;nbsp;&amp;nbsp; &lt;/p&gt;</TD></TR><TR><TD CLASS="l">165</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">166</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; This flag indicates whether or not the frame is encrypted. If set,&lt;br&gt;</TD></TR><TR><TD CLASS="l">167</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; one byte indicating with which method it was encrypted will be&lt;br&gt;</TD></TR><TR><TD CLASS="l">168</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; added to the frame. See description of the ENCR frame for more&lt;br&gt;</TD></TR><TR><TD CLASS="l">169</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; information about encryption method registration. Encryption&lt;br&gt;</TD></TR><TR><TD CLASS="l">170</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; should be done after compression. Whether or not setting this flag&lt;br&gt;</TD></TR><TR><TD CLASS="l">171</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; requires the presence of a 'Data Length Indicator' depends on the&lt;br&gt;</TD></TR><TR><TD CLASS="l">172</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; specific algorithm used.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">173</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">174</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame is not encrypted.&lt;br&gt;</TD></TR><TR><TD CLASS="l">175</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame is encrypted.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">176</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">177</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; n - Unsynchronisation&lt;/p&gt;</TD></TR><TR><TD CLASS="l">178</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">179</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; This flag indicates whether or not unsynchronisation was applied&lt;br&gt;</TD></TR><TR><TD CLASS="l">180</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; to this frame. See section 6 for details on unsynchronisation.&lt;br&gt;</TD></TR><TR><TD CLASS="l">181</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; If this flag is set all data from the end of this header to the&lt;br&gt;</TD></TR><TR><TD CLASS="l">182</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; end of this frame has been unsynchronised. Although desirable, the&lt;br&gt;</TD></TR><TR><TD CLASS="l">183</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; presence of a 'Data Length Indicator' is not made mandatory by&lt;br&gt;</TD></TR><TR><TD CLASS="l">184</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; unsynchronisation.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">185</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">186</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame has not been unsynchronised.&lt;br&gt;</TD></TR><TR><TD CLASS="l">187</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Frame has been unsyrchronised.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">188</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">189</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp; p - Data length indicator&lt;/p&gt;</TD></TR><TR><TD CLASS="l">190</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">191</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; This flag indicates that a data length indicator has been added to&lt;br&gt;</TD></TR><TR><TD CLASS="l">192</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; the frame. The data length indicator is the value one would write&lt;br&gt;</TD></TR><TR><TD CLASS="l">193</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; as the 'Frame length' if all of the frame format flags were&lt;br&gt;</TD></TR><TR><TD CLASS="l">194</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; zeroed, represented as a 32 bit synchsafe integer.&lt;/p&gt;</TD></TR><TR><TD CLASS="l">195</TD><TD> * &lt;p/&gt;</TD></TR><TR><TD CLASS="l">196</TD><TD> * &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 0&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; There is no Data Length Indicator.&lt;br&gt;</TD></TR><TR><TD CLASS="l">197</TD><TD> * &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; A data length Indicator has been added to the</TD></TR><TR><TD CLASS="l">198</TD><TD> * frame.&lt;br&gt; &lt;/p&gt;</TD></TR><TR><TD CLASS="l">199</TD><TD> *</TD></TR><TR><TD CLASS="l">200</TD><TD> * @author Eric Farng</TD></TR><TR><TD CLASS="l">201</TD><TD> * @version $Revision: 1.6 $</TD></TR><TR><TD CLASS="l">202</TD><TD> */</TD></TR><TR><TD CLASS="l">203</TD><TD>public class ID3v2_4Frame extends ID3v2_3Frame {</TD></TR><TR><TD CLASS="l">204</TD><TD> </TD></TR><TR CLASS="c"><TD CLASS="l">205</TD><TD>    protected boolean dataLengthIndicator = false;</TD></TR><TR CLASS="c"><TD CLASS="l">206</TD><TD>    protected boolean unsynchronization = false;</TD></TR><TR><TD CLASS="l"><A NAME="0">207</A></TD><TD> </TD></TR><TR><TD CLASS="l">208</TD><TD>    /**</TD></TR><TR><TD CLASS="l">209</TD><TD>     * Creates a new ID3v2_4Frame object.</TD></TR><TR><TD CLASS="l">210</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">211</TD><TD>    public ID3v2_4Frame() {</TD></TR><TR><TD CLASS="l">212</TD><TD>        // base empty constructor</TD></TR><TR CLASS="c"><TD CLASS="l">213</TD><TD>    }</TD></TR><TR><TD CLASS="l">214</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="8">215</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">216</TD><TD>     * Creates a new ID3v2_4Frame object.</TD></TR><TR><TD CLASS="l">217</TD><TD>     */</TD></TR><TR><TD CLASS="l">218</TD><TD>    public ID3v2_4Frame(final ID3v2_4Frame copyObject) {</TD></TR><TR CLASS="c"><TD CLASS="l">219</TD><TD>        super(copyObject);</TD></TR><TR CLASS="c"><TD CLASS="l">220</TD><TD>        this.dataLengthIndicator = copyObject.dataLengthIndicator;</TD></TR><TR CLASS="c"><TD CLASS="l">221</TD><TD>        this.unsynchronization = copyObject.unsynchronization;</TD></TR><TR CLASS="c"><TD CLASS="l">222</TD><TD>    }</TD></TR><TR><TD CLASS="l">223</TD><TD> </TD></TR><TR><TD CLASS="l"><A NAME="7">224</A></TD><TD>    /**</TD></TR><TR><TD CLASS="l">225</TD><TD>     * Creates a new ID3v2_4Frame object.</TD></TR><TR><TD CLASS="l">226</TD><TD>     */</TD></TR><TR><TD CLASS="l">227</TD><TD>    public ID3v2_4Frame(final AbstractID3v2FrameBody body) {</TD></TR><TR CLASS="c"><TD CLASS="l">228</TD><TD>        super(body);</TD></TR><TR CLASS="c"><TD CLASS="l">229</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="5">230</A></TD><TD> </TD></TR><TR><TD CLASS="l">231</TD><TD>    /**</TD></TR><TR><TD CLASS="l">232</TD><TD>     * Creates a new ID3v2_4Frame object.</TD></TR><TR><TD CLASS="l">233</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">234</TD><TD>    public ID3v2_4Frame(final AbstractID3v2Frame frame) {</TD></TR><TR CLASS="c"><TD CLASS="l">235</TD><TD>        if (frame instanceof ID3v2_4Frame) {</TD></TR><TR CLASS="c"><TD CLASS="l">236</TD><TD>            final ID3v2_4Frame f = (ID3v2_4Frame) frame;</TD></TR><TR CLASS="c"><TD CLASS="l">237</TD><TD>            this.unsynchronization = f.unsynchronization;</TD></TR><TR CLASS="c"><TD CLASS="l">238</TD><TD>            this.dataLengthIndicator = f.dataLengthIndicator;</TD></TR><TR><TD CLASS="l">239</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">240</TD><TD>        if (frame instanceof ID3v2_3Frame) {</TD></TR><TR><TD CLASS="l">241</TD><TD>            // a id3v2_4 frame is of type id3v2_3 frame also ...</TD></TR><TR CLASS="c"><TD CLASS="l">242</TD><TD>            final ID3v2_3Frame f = (ID3v2_3Frame) frame;</TD></TR><TR CLASS="c"><TD CLASS="l">243</TD><TD>            this.tagAlterPreservation = f.tagAlterPreservation;</TD></TR><TR CLASS="c"><TD CLASS="l">244</TD><TD>            this.fileAlterPreservation = f.fileAlterPreservation;</TD></TR><TR CLASS="c"><TD CLASS="l">245</TD><TD>            this.readOnly = f.readOnly;</TD></TR><TR CLASS="c"><TD CLASS="l">246</TD><TD>            this.groupingIdentity = f.groupingIdentity;</TD></TR><TR CLASS="c"><TD CLASS="l">247</TD><TD>            this.compression = f.compression;</TD></TR><TR CLASS="c"><TD CLASS="l">248</TD><TD>            this.encryption = f.encryption;</TD></TR><TR><TD CLASS="l">249</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">250</TD><TD>        if (frame instanceof ID3v2_2Frame) {</TD></TR><TR><TD CLASS="l">251</TD><TD>            // no variables yet</TD></TR><TR><TD CLASS="l">252</TD><TD>        }</TD></TR><TR CLASS="p"><TD TITLE="75% line coverage (3 out of 4 instructions)" CLASS="l">253</TD><TD TITLE="75% line coverage (3 out of 4 instructions)">        if (frame.getBody() == null) {</TD></TR><TR><TD CLASS="l">254</TD><TD>            // do nothing</TD></TR><TR CLASS="c"><TD CLASS="l">255</TD><TD>        } else if (TagUtility.isID3v2_4FrameIdentifier(frame.getIdentifier())) {</TD></TR><TR CLASS="c"><TD CLASS="l">256</TD><TD>            this.setBody((AbstractID3v2FrameBody) TagUtility.copyObject(frame.getBody()));</TD></TR><TR><TD CLASS="l">257</TD><TD>//        } else if (TagUtility.isID3v2_3FrameIdentifier(frame.getIdentifier())) {</TD></TR><TR><TD CLASS="l">258</TD><TD>//            // @TODO correctly convert tags</TD></TR><TR><TD CLASS="l">259</TD><TD>//            this.setBody((AbstractID3v2FrameBody) TagUtility.copyObject(frame.getBody()));</TD></TR><TR><TD CLASS="l">260</TD><TD>//        } else if (TagUtility.isID3v2_2FrameIdentifier(frame.getIdentifier())) {</TD></TR><TR><TD CLASS="l">261</TD><TD>//            // @TODO correctly convert tags</TD></TR><TR><TD CLASS="l">262</TD><TD>//            this.setBody((AbstractID3v2FrameBody) TagUtility.copyObject(frame.getBody()));</TD></TR><TR><TD CLASS="l">263</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">264</TD><TD>    }</TD></TR><TR><TD CLASS="l">265</TD><TD> </TD></TR><TR><TD CLASS="l">266</TD><TD>    /**</TD></TR><TR><TD CLASS="l">267</TD><TD>     * Creates a new ID3v2_4Frame object.</TD></TR><TR><TD CLASS="l">268</TD><TD>     */</TD></TR><TR><TD CLASS="l">269</TD><TD>    public ID3v2_4Frame(final boolean readOnly,</TD></TR><TR><TD CLASS="l">270</TD><TD>                        final boolean groupingIdentity,</TD></TR><TR><TD CLASS="l">271</TD><TD>                        final boolean compression,</TD></TR><TR><TD CLASS="l"><A NAME="a">272</A></TD><TD>                        final boolean encryption,</TD></TR><TR><TD CLASS="l">273</TD><TD>                        final boolean unsynchronization,</TD></TR><TR><TD CLASS="l">274</TD><TD>                        final boolean dataLengthIndicator,</TD></TR><TR><TD CLASS="l">275</TD><TD>                        final AbstractID3v2FrameBody body) {</TD></TR><TR CLASS="c"><TD CLASS="l">276</TD><TD>        super(body);</TD></TR><TR CLASS="c"><TD CLASS="l">277</TD><TD>        this.readOnly = readOnly;</TD></TR><TR CLASS="c"><TD CLASS="l">278</TD><TD>        this.groupingIdentity = groupingIdentity;</TD></TR><TR CLASS="c"><TD CLASS="l">279</TD><TD>        this.compression = compression;</TD></TR><TR CLASS="c"><TD CLASS="l">280</TD><TD>        this.encryption = encryption;</TD></TR><TR CLASS="c"><TD CLASS="l">281</TD><TD>        this.unsynchronization = unsynchronization;</TD></TR><TR CLASS="c"><TD CLASS="l">282</TD><TD>        this.dataLengthIndicator = dataLengthIndicator;</TD></TR><TR CLASS="c"><TD CLASS="l">283</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="3">284</A></TD><TD> </TD></TR><TR><TD CLASS="l">285</TD><TD>    /**</TD></TR><TR><TD CLASS="l">286</TD><TD>     * Creates a new ID3v2_4Frame object.</TD></TR><TR><TD CLASS="l">287</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">288</TD><TD>    public ID3v2_4Frame(final Lyrics3v2Field field) throws InvalidTagException {</TD></TR><TR CLASS="c"><TD CLASS="l">289</TD><TD>        final String id = field.getIdentifier();</TD></TR><TR><TD CLASS="l">290</TD><TD>        final String value;</TD></TR><TR CLASS="c"><TD CLASS="l">291</TD><TD>        if (id.equals(&#34;IND&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">292</TD><TD>            throw new InvalidTagException(&#34;Cannot create ID3v2.40 frame from Lyrics3 indications field.&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">293</TD><TD>        } else if (id.equals(&#34;LYR&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">294</TD><TD>            final FieldBodyLYR lyric = (FieldBodyLYR) field.getBody();</TD></TR><TR><TD CLASS="l">295</TD><TD>            ObjectLyrics3Line line;</TD></TR><TR CLASS="c"><TD CLASS="l">296</TD><TD>            final Iterator iterator = lyric.iterator();</TD></TR><TR><TD CLASS="l">297</TD><TD>            final FrameBodySYLT sync;</TD></TR><TR><TD CLASS="l">298</TD><TD>            final FrameBodyUSLT unsync;</TD></TR><TR CLASS="c"><TD CLASS="l">299</TD><TD>            final boolean hasTimeStamp = lyric.hasTimeStamp();</TD></TR><TR><TD CLASS="l">300</TD><TD> </TD></TR><TR><TD CLASS="l">301</TD><TD>            // we'll create only one frame here.</TD></TR><TR><TD CLASS="l">302</TD><TD>            // if there is any timestamp at all, we will create a sync'ed frame.</TD></TR><TR CLASS="c"><TD CLASS="l">303</TD><TD>            sync = new FrameBodySYLT((byte) 0, &#34;ENG&#34;, (byte) 2, (byte) 1, &#34;&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">304</TD><TD>            unsync = new FrameBodyUSLT((byte) 0, &#34;ENG&#34;, &#34;&#34;, &#34;&#34;);</TD></TR><TR CLASS="c"><TD CLASS="l">305</TD><TD>            while (iterator.hasNext()) {</TD></TR><TR CLASS="c"><TD CLASS="l">306</TD><TD>                line = (ObjectLyrics3Line) iterator.next();</TD></TR><TR CLASS="c"><TD CLASS="l">307</TD><TD>                if (hasTimeStamp) {</TD></TR><TR CLASS="c"><TD CLASS="l">308</TD><TD>                    sync.addLyric(line);</TD></TR><TR><TD CLASS="l">309</TD><TD>                } else {</TD></TR><TR CLASS="c"><TD CLASS="l">310</TD><TD>                    unsync.addLyric(line);</TD></TR><TR><TD CLASS="l">311</TD><TD>                }</TD></TR><TR><TD CLASS="l">312</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">313</TD><TD>            if (hasTimeStamp) {</TD></TR><TR CLASS="c"><TD CLASS="l">314</TD><TD>                this.setBody(sync);</TD></TR><TR><TD CLASS="l">315</TD><TD>            } else {</TD></TR><TR CLASS="c"><TD CLASS="l">316</TD><TD>                this.setBody(unsync);</TD></TR><TR><TD CLASS="l">317</TD><TD>            }</TD></TR><TR CLASS="c"><TD CLASS="l">318</TD><TD>        } else if (id.equals(&#34;INF&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">319</TD><TD>            value = ((FieldBodyINF) field.getBody()).getAdditionalInformation();</TD></TR><TR CLASS="c"><TD CLASS="l">320</TD><TD>            this.setBody(new FrameBodyCOMM((byte) 0, &#34;ENG&#34;, &#34;&#34;, value));</TD></TR><TR CLASS="c"><TD CLASS="l">321</TD><TD>        } else if (id.equals(&#34;AUT&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">322</TD><TD>            value = ((FieldBodyAUT) field.getBody()).getAuthor();</TD></TR><TR CLASS="c"><TD CLASS="l">323</TD><TD>            this.setBody(new FrameBodyTCOM((byte) 0, value));</TD></TR><TR CLASS="c"><TD CLASS="l">324</TD><TD>        } else if (id.equals(&#34;EAL&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">325</TD><TD>            value = ((FieldBodyEAL) field.getBody()).getAlbum();</TD></TR><TR CLASS="c"><TD CLASS="l">326</TD><TD>            this.setBody(new FrameBodyTALB((byte) 0, value));</TD></TR><TR CLASS="c"><TD CLASS="l">327</TD><TD>        } else if (id.equals(&#34;EAR&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">328</TD><TD>            value = ((FieldBodyEAR) field.getBody()).getArtist();</TD></TR><TR CLASS="c"><TD CLASS="l">329</TD><TD>            this.setBody(new FrameBodyTPE1((byte) 0, value));</TD></TR><TR CLASS="c"><TD CLASS="l">330</TD><TD>        } else if (id.equals(&#34;ETT&#34;)) {</TD></TR><TR CLASS="c"><TD CLASS="l">331</TD><TD>            value = ((FieldBodyETT) field.getBody()).getTitle();</TD></TR><TR CLASS="c"><TD CLASS="l">332</TD><TD>            this.setBody(new FrameBodyTIT2((byte) 0, value));</TD></TR><TR CLASS="z"><TD CLASS="l">333</TD><TD>        } else if (id.equals(&#34;IMG&#34;)) {</TD></TR><TR CLASS="z"><TD CLASS="l">334</TD><TD>            throw new InvalidTagException(&#34;Cannot create ID3v2.40 frame from Lyrics3 image field.&#34;);</TD></TR><TR><TD CLASS="l">335</TD><TD>        } else {</TD></TR><TR CLASS="z"><TD CLASS="l">336</TD><TD>            throw new InvalidTagException(&#34;Cannot caret ID3v2.40 frame from &#34; + id + &#34; Lyrics3 field&#34;);</TD></TR><TR><TD CLASS="l">337</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">338</TD><TD>    }</TD></TR><TR><TD CLASS="l"><A NAME="9">339</A></TD><TD> </TD></TR><TR><TD CLASS="l">340</TD><TD>    /**</TD></TR><TR><TD CLASS="l">341</TD><TD>     * Creates a new ID3v2_4Frame object.</TD></TR><TR><TD CLASS="l">342</TD><TD>     */</TD></TR><TR CLASS="c"><TD CLASS="l">343</TD><TD>    public ID3v2_4Frame(final RandomAccessFile file) throws IOException, InvalidTagException {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="b">344</A></TD><TD>        this.read(file);</TD></TR><TR CLASS="c"><TD CLASS="l">345</TD><TD>    }</TD></TR><TR><TD CLASS="l">346</TD><TD> </TD></TR><TR><TD CLASS="l">347</TD><TD>    public int getSize() {</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="2">348</A></TD><TD>        return this.getBody().getSize() + 4 + 2 + 4;</TD></TR><TR><TD CLASS="l">349</TD><TD>    }</TD></TR><TR><TD CLASS="l">350</TD><TD> </TD></TR><TR><TD CLASS="l">351</TD><TD>    public boolean equals(final Object obj) {</TD></TR><TR CLASS="c"><TD CLASS="l">352</TD><TD>        if ((obj instanceof ID3v2_4Frame) == false) {</TD></TR><TR CLASS="z"><TD CLASS="l">353</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">354</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">355</TD><TD>        final ID3v2_4Frame id3v2_4Frame = (ID3v2_4Frame) obj;</TD></TR><TR CLASS="c"><TD CLASS="l">356</TD><TD>        if (this.unsynchronization != id3v2_4Frame.unsynchronization) {</TD></TR><TR CLASS="z"><TD CLASS="l">357</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">358</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">359</TD><TD>        if (this.dataLengthIndicator != id3v2_4Frame.dataLengthIndicator) {</TD></TR><TR CLASS="z"><TD CLASS="l">360</TD><TD>            return false;</TD></TR><TR><TD CLASS="l">361</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">362</TD><TD>        return super.equals(obj);</TD></TR><TR><TD CLASS="l"><A NAME="4">363</A></TD><TD>    }</TD></TR><TR><TD CLASS="l">364</TD><TD> </TD></TR><TR><TD CLASS="l">365</TD><TD>    public void read(final RandomAccessFile file) throws IOException, InvalidTagException {</TD></TR><TR><TD CLASS="l">366</TD><TD>        long filePointer;</TD></TR><TR CLASS="c"><TD CLASS="l">367</TD><TD>        final byte[] buffer = new byte[4];</TD></TR><TR><TD CLASS="l">368</TD><TD>        byte b;</TD></TR><TR><TD CLASS="l">369</TD><TD> </TD></TR><TR><TD CLASS="l">370</TD><TD>        // lets scan for a non-zero byte;</TD></TR><TR><TD CLASS="l">371</TD><TD>        do {</TD></TR><TR CLASS="c"><TD CLASS="l">372</TD><TD>            filePointer = file.getFilePointer();</TD></TR><TR CLASS="c"><TD CLASS="l">373</TD><TD>            b = file.readByte();</TD></TR><TR CLASS="c"><TD CLASS="l">374</TD><TD>            org.farng.mp3.id3.AbstractID3v2.incrementPaddingCounter();</TD></TR><TR CLASS="c"><TD CLASS="l">375</TD><TD>        } while (b == 0);</TD></TR><TR CLASS="c"><TD CLASS="l">376</TD><TD>        file.seek(filePointer);</TD></TR><TR CLASS="c"><TD CLASS="l">377</TD><TD>        org.farng.mp3.id3.AbstractID3v2.decrementPaddingCounter();</TD></TR><TR><TD CLASS="l">378</TD><TD> </TD></TR><TR><TD CLASS="l">379</TD><TD>        // read the four character identifier</TD></TR><TR CLASS="c"><TD CLASS="l">380</TD><TD>        file.read(buffer, 0, 4);</TD></TR><TR CLASS="c"><TD CLASS="l">381</TD><TD>        final String identifier = new String(buffer, 0, 4);</TD></TR><TR><TD CLASS="l">382</TD><TD> </TD></TR><TR><TD CLASS="l">383</TD><TD>        // is this a valid identifier?</TD></TR><TR CLASS="c"><TD CLASS="l">384</TD><TD>        if (isValidID3v2FrameIdentifier(identifier) == false) {</TD></TR><TR CLASS="c"><TD CLASS="l">385</TD><TD>            file.seek(file.getFilePointer() - 3);</TD></TR><TR CLASS="c"><TD CLASS="l">386</TD><TD>            throw new InvalidTagException(identifier + &#34; is not a valid ID3v2.40 frame&#34;);</TD></TR><TR><TD CLASS="l">387</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">388</TD><TD>        filePointer = file.getFilePointer();</TD></TR><TR><TD CLASS="l">389</TD><TD> </TD></TR><TR><TD CLASS="l">390</TD><TD>        // skip the 4 byte size</TD></TR><TR CLASS="c"><TD CLASS="l">391</TD><TD>        file.skipBytes(4);</TD></TR><TR><TD CLASS="l">392</TD><TD> </TD></TR><TR><TD CLASS="l">393</TD><TD>        // read the flag bytes</TD></TR><TR CLASS="c"><TD CLASS="l">394</TD><TD>        file.read(buffer, 0, 2);</TD></TR><TR CLASS="p"><TD TITLE="94% line coverage (29 out of 31 instructions)" CLASS="l">395</TD><TD TITLE="94% line coverage (29 out of 31 instructions)">        this.tagAlterPreservation = (buffer[0] &amp; TagConstant.MASK_V24_TAG_ALTER_PRESERVATION) != 0;</TD></TR><TR CLASS="p"><TD TITLE="95% line coverage (18 out of 19 instructions)" CLASS="l">396</TD><TD TITLE="95% line coverage (18 out of 19 instructions)">        this.fileAlterPreservation = (buffer[0] &amp; TagConstant.MASK_V24_FILE_ALTER_PRESERVATION) != 0;</TD></TR><TR CLASS="c"><TD CLASS="l">397</TD><TD>        this.readOnly = (buffer[0] &amp; TagConstant.MASK_V24_READ_ONLY) != 0;</TD></TR><TR CLASS="p"><TD TITLE="89% line coverage (17 out of 19 instructions)" CLASS="l">398</TD><TD TITLE="89% line coverage (17 out of 19 instructions)">        this.groupingIdentity = (buffer[1] &amp; TagConstant.MASK_V24_GROUPING_IDENTITY) != 0;</TD></TR><TR CLASS="p"><TD TITLE="89% line coverage (17 out of 19 instructions)" CLASS="l">399</TD><TD TITLE="89% line coverage (17 out of 19 instructions)">        this.compression = (buffer[1] &amp; TagConstant.MASK_V24_COMPRESSION) != 0;</TD></TR><TR CLASS="p"><TD TITLE="89% line coverage (17 out of 19 instructions)" CLASS="l">400</TD><TD TITLE="89% line coverage (17 out of 19 instructions)">        this.encryption = (buffer[1] &amp; TagConstant.MASK_V24_ENCRYPTION) != 0;</TD></TR><TR CLASS="p"><TD TITLE="89% line coverage (17 out of 19 instructions)" CLASS="l">401</TD><TD TITLE="89% line coverage (17 out of 19 instructions)">        this.unsynchronization = (buffer[1] &amp; TagConstant.MASK_V24_FRAME_UNSYNCHRONIZATION) != 0;</TD></TR><TR CLASS="c"><TD CLASS="l">402</TD><TD>        this.dataLengthIndicator = (buffer[1] &amp; TagConstant.MASK_V24_DATA_LENGTH_INDICATOR) != 0;</TD></TR><TR CLASS="c"><TD CLASS="l">403</TD><TD>        file.seek(filePointer);</TD></TR><TR CLASS="c"><TD CLASS="l"><A NAME="1">404</A></TD><TD>        this.setBody(readBody(identifier, file));</TD></TR><TR CLASS="c"><TD CLASS="l">405</TD><TD>    }</TD></TR><TR><TD CLASS="l">406</TD><TD> </TD></TR><TR><TD CLASS="l">407</TD><TD>    public void write(final RandomAccessFile file) throws IOException {</TD></TR><TR CLASS="c"><TD CLASS="l">408</TD><TD>        final byte[] buffer = new byte[4];</TD></TR><TR><TD CLASS="l">409</TD><TD>        final long filePointer;</TD></TR><TR CLASS="c"><TD CLASS="l">410</TD><TD>        final String str = TagUtility.truncate(getIdentifier(), 4);</TD></TR><TR CLASS="c"><TD CLASS="l">411</TD><TD>        for (int i = 0; i &lt; str.length(); i++) {</TD></TR><TR CLASS="c"><TD CLASS="l">412</TD><TD>            buffer[i] = (byte) str.charAt(i);</TD></TR><TR><TD CLASS="l">413</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">414</TD><TD>        file.write(buffer, 0, str.length());</TD></TR><TR CLASS="c"><TD CLASS="l">415</TD><TD>        filePointer = file.getFilePointer();</TD></TR><TR><TD CLASS="l">416</TD><TD> </TD></TR><TR><TD CLASS="l">417</TD><TD>        // skip the size bytes</TD></TR><TR CLASS="c"><TD CLASS="l">418</TD><TD>        file.skipBytes(4);</TD></TR><TR CLASS="c"><TD CLASS="l">419</TD><TD>        setAlterPreservation();</TD></TR><TR CLASS="c"><TD CLASS="l">420</TD><TD>        buffer[0] = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">421</TD><TD>        buffer[1] = 0;</TD></TR><TR CLASS="c"><TD CLASS="l">422</TD><TD>        if (this.tagAlterPreservation) {</TD></TR><TR CLASS="z"><TD CLASS="l">423</TD><TD>            buffer[0] |= TagConstant.MASK_V24_TAG_ALTER_PRESERVATION;</TD></TR><TR><TD CLASS="l">424</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">425</TD><TD>        if (this.fileAlterPreservation) {</TD></TR><TR CLASS="c"><TD CLASS="l">426</TD><TD>            buffer[0] |= TagConstant.MASK_V24_FILE_ALTER_PRESERVATION;</TD></TR><TR><TD CLASS="l">427</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">428</TD><TD>        if (this.readOnly) {</TD></TR><TR CLASS="z"><TD CLASS="l">429</TD><TD>            buffer[0] |= TagConstant.MASK_V24_READ_ONLY;</TD></TR><TR><TD CLASS="l">430</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">431</TD><TD>        if (this.groupingIdentity) {</TD></TR><TR CLASS="z"><TD CLASS="l">432</TD><TD>            buffer[1] |= TagConstant.MASK_V24_GROUPING_IDENTITY;</TD></TR><TR><TD CLASS="l">433</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">434</TD><TD>        if (this.compression) {</TD></TR><TR CLASS="z"><TD CLASS="l">435</TD><TD>            buffer[1] |= TagConstant.MASK_V24_COMPRESSION;</TD></TR><TR><TD CLASS="l">436</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">437</TD><TD>        if (this.encryption) {</TD></TR><TR CLASS="z"><TD CLASS="l">438</TD><TD>            buffer[1] |= TagConstant.MASK_V24_ENCRYPTION;</TD></TR><TR><TD CLASS="l">439</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">440</TD><TD>        if (this.unsynchronization) {</TD></TR><TR CLASS="z"><TD CLASS="l">441</TD><TD>            buffer[1] |= TagConstant.MASK_V24_FRAME_UNSYNCHRONIZATION;</TD></TR><TR><TD CLASS="l">442</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">443</TD><TD>        if (this.dataLengthIndicator) {</TD></TR><TR CLASS="z"><TD CLASS="l">444</TD><TD>            buffer[1] |= TagConstant.MASK_V24_DATA_LENGTH_INDICATOR;</TD></TR><TR><TD CLASS="l">445</TD><TD>        }</TD></TR><TR CLASS="c"><TD CLASS="l">446</TD><TD>        file.write(buffer, 0, 2);</TD></TR><TR CLASS="c"><TD CLASS="l">447</TD><TD>        file.seek(filePointer);</TD></TR><TR CLASS="c"><TD CLASS="l">448</TD><TD>        this.getBody().write(file);</TD></TR><TR CLASS="c"><TD CLASS="l">449</TD><TD>    }</TD></TR><TR><TD CLASS="l">450</TD><TD>}</TD></TR></TABLE><P></P><TABLE CLASS="hdft" WIDTH="100%" CELLSPACING="0"><TR><TD CLASS="nv">[<A HREF="../coverage.html">all classes</A>][<A HREF="0.html">org.farng.mp3.id3</A>]</TD></TR><TR><TD CLASS="tl"><A HREF="http://sourceforge.net/projects/emma">EMMA 2.0.5312</A> (C) Vladimir Roubtsov</TD></TR></TABLE></BODY></HTML>